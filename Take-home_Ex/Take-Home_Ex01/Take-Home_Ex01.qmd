---
title: "Take-Home Exercise 1: Application of Spatial Point Patterns Analysis to discover the geographical distribution of functional and non-function water points in Osun State, Nigeria"
author: "Gail Teh"
date: "30 January 2023"
date-modified: "`r Sys.Date()`"
execute: 
  echo: true
  eval: true
  warning: false
editor: visual
---

# Introduction

This analysis aims to analyse the distribution of the functional and non-functional water points and their co-locations in Osun State of Nigeria.

The 3 main parts of this analysis are:

1.  Exploratory Spatial Data Analysis

2.  Second Order Spatial Ppoint Patterns Analysis

3.  Spatial Correlation Analysis

# Data Used

## Geospatial Data

The geospatial data we will be using is Nigeria's state boundary polygon feature GIS data from The [Humanitarian Data Exchange](https://data.humdata.org/) portal and [geoBoundaries](https://www.geoboundaries.org/). In this exercise, we will be using the ADM2 data sets.

## Aspatial Data

The aspatial data used in this exercise will be the **WPdx+** data set from the [WPdx Global Data Repositries.](https://www.waterpointdata.org/access-data/) This contains data about water points of each country around the world.

Note: There are 2 versions of the data WPdx-Basic and WPdx+, but we are required to use WPdx+

# Installing and Loading Packages

This code chunk is run to install and load the R packages used for this exercise.

```{r}
pacman::p_load(sf, tidyverse, funModeling, tmap, maptools, raster, spatstat)
```

# Importing Data

## Importing Geospatial Data

In this section, we will import the Nigeria boundary data sets and then store them into their respective data frames.

Using st_read(), we will read the geospatial data.

```{r}
geoNGA <- st_read("data/geospatial/",
                  layer = "geoBoundaries-NGA-ADM2")
```

```{r}
NGA <- st_read("data/geospatial/",
               layer = "nga_admbnda_adm2_osgof_20190417")
```

By observing both dataframes, NGA provides both LGA and state information. Hence, we will proceed with using the NGA data frame for subsequent processing.

### Checking Coordinate System

Before proceeding further, We need to check if the data is in the correct Projected Coordinate System.

```{r}
st_crs(NGA)
```

Our projected CRS should be Nigeria's Projected Coordinate System, 26392, not 4326. Hence, we need to transform the data into the appropriate projected coordinate system.

```{r}
NGA <- st_transform(NGA, crs = 26392 )
```

Checking the CRS again:

```{r}
st_crs(NGA)
```

Now it is in the appropriate EPSG code.

## Aspatial Data

Here, we will be importing the aspatial water point data, and at the same time filtering and selecting only the water points within Nigeria. After which, we will store it into a tibble data frame.

```{r}
wp_nga <- read_csv("data/aspatial/WPdx.csv") %>%
  filter(`#clean_country_name` == "Nigeria")
```

### Converting into sf data frame

First, we need to convert the wkt field into sfc field using st_as_sfc().

```{r}
wp_nga$Geometry = st_as_sfc(wp_nga$`New Georeferenced Column`)
```

Next, we will convert the tibble data frame into a sf data frame using st_sf().

```{r}
wp_sf <- st_sf(wp_nga, crs=4326)
wp_sf
```

### Transforming into Nigeria Projected Coordinate System

```{r}
wp_sf <- wp_sf %>%
  st_transform(crs = 26392)
```

# Geospatial Data Cleaning

Now that we have imported the data, before starting any analysis, we need to clean our data so that it would not affect future analysis results.

## Excluding Redundant Fields

We will use select() of dplyr to retain columns 3,4,8 and 9. Columns 8 & 9 is the name and code of the ADM1 boundaries, which is at the state level boundary, while columns 3 and 4 is the name and code of ADM2 boundaries, which is at the city level.

```{r}
NGA <- NGA %>%
  dplyr::select(c(3:4, 8:9))
```

Since our focus is on Osun State, we will create a data frame with just the data from Osun state.

```{r}
NGA_Osun <- NGA %>% filter(`ADM1_EN` == "Osun")
NGA_Osun
```

# Data Wrangling for Water point Data

Next, we want to find out the distribution of the types of water point. We will do this by using freq() from the funModeling package.

```{r}
funModeling::freq(data = wp_sf,
     input = '#status_clean')
```

From this we can see there are 9 classes in the #status_clean fields. Now, we will perform data wrangling:

-   rename() to rename the column from #status_clean to status_clean for easier handling

-   select() to include status_clean into the output sf data frame

-   From observing the data, the #status_clean column has NA data, so we will use mutate() and replace_na() to recode the NA values into "unknown"

```{r}
wp_sf_nga <- wp_sf %>% 
  rename(status_clean = '#status_clean') %>%
  dplyr::select(status_clean) %>%
  mutate(status_clean = replace_na(
    status_clean, "unknown"))
```

## Extracting Water Point Data

Now, we will extract the water point data according to their types.

**Extracting Functional Water points**

```{r}
wp_functional <- wp_sf_nga %>%
  filter(status_clean %in%
           c("Functional",
             "Functional but not in use",
             "Functional but needs repair"))
```

**Extracting nonfunctional water points**

```{r}
wp_nonfunctional <- wp_sf_nga %>%
  filter(status_clean %in%
           c("Abandoned/Decommissioned",
             "Abandoned",
             "Non-Functional due to dry season",
             "Non-Functional",
             "Non functional due to dry season"))
```

**Extracting water points with unknown status**

```{r}
wp_unknown <- wp_sf_nga %>%
  filter(status_clean == "unknown")
```

# Combined Data Wrangling

Before doing our analysis, we need to convert the data into appropriate formats

## Converting sf data frames intp sp's Spatial class

First, we have to convert the sf data frames into spatial classes (the Osun boundary, functional and nonfunctional water points)

```{r}
NGA_Osun_spatial <- as_Spatial(NGA_Osun)
wp_functional_spatial <- as_Spatial(wp_functional)
wp_nonfunctional_spatial <- as_Spatial(wp_nonfunctional)
```

Checking the new spatial classes

```{r}
NGA_Osun_spatial
```

```{r}
wp_functional_spatial
```

```{r}
wp_nonfunctional_spatial
```

They have been converted to spatial classes!

## Converting from Spatial Class into generic sp format

spatstat (what we will be using point pattern analysis) requires the data to be in ppp form. As there is no direct way to convert a Spatial\* class into a ppp object, we need to do an intermediate step of converting the Spatial class into a spatial object.

```{r}
NGA_Osun_sp <- as(NGA_Osun_spatial, "SpatialPolygons")
wp_functional_sp <- as(wp_functional_spatial, "SpatialPoints")
wp_nonfunctional_sp <- as(wp_nonfunctional_spatial, "SpatialPoints")
```

```{r}
NGA_Osun_sp
```

```{r}
wp_functional_sp
```

```{r}
wp_nonfunctional_sp
```

Now they are in their respective sp objects

## Converting the generic sp format into spatstat's ppp format

Finally, we can use as.ppp() of spatstat to convert the spatial data into spatstat's ppp object format. We only need to do this for the point features, hence we will not be including the 'base map' NGA_Osun as it is a polygon feature.

```{r}
wp_functional_ppp <- as(wp_functional_sp, "ppp")
wp_nonfunctional_ppp <- as(wp_nonfunctional_sp, "ppp")
```

We can check the summary statistics of the ppp objects:

```{r}
summary(wp_functional_ppp)
```

```{r}
summary(wp_nonfunctional_ppp)
```

From this summary, we can see that there are no duplicated points so we can move on to the next part of the analysis.

## Owin object

When we analyse spatial point patterns, it is best to confine the analysis within a geographical area. We can use an object called owin in spatstat to specially design this polygonal region.

Converting our NGA_Osun_sp SpatialPolygon object into an owin object.

```{r}
NGA_Osun_owin <- as(NGA_Osun_sp, "owin")
plot(NGA_Osun_owin)
```

## Combining point events object and owin object

In here, we will extract the relevant events located within Osun state.

```{r}
osun_wp_functional_ppp = wp_functional_ppp[NGA_Osun_owin]
osun_wp_nonfunctional_ppp = wp_nonfunctional_ppp[NGA_Osun_owin]
```

Below is a visualisation:

```{r}
par(mfrow=c(1,2))
plot(osun_wp_functional_ppp)
plot(osun_wp_nonfunctional_ppp)
```

# Exploratory Spatial Data Analysis

In this section, we will carry out first-order SPPA using spatstat.

## Kernel Density Estimation (KDE)

### Rescaling to kilometer

```{r}
osun_wp_functional_ppp.km <- rescale(osun_wp_functional_ppp, 1000, "km")
osun_wp_nonfunctional_ppp.km <- rescale(osun_wp_nonfunctional_ppp, 1000, "km")
```

### Computing KDE

There are different bandwidth methods we can use, but based on the visualisation above, I can see that both the functional and non-functional water points have predominantly tight clusters. Hence, I have decided to use the bw.ppl() for the analysis.

```{r}
osun_wp_functional.ppl <- density(osun_wp_functional_ppp.km,
                                  sigma=bw.ppl,
                                  edge=TRUE,
                                  kernel="gaussian")

osun_wp_nonfunctional.ppl <- density(osun_wp_nonfunctional_ppp.km,
                                     sigma=bw.ppl,
                                     edge=TRUE,
                                     kernel="gaussian")
```

### Plotting KDE

```{r}
par(mfrow=c(1,2))
plot(osun_wp_functional.ppl)
plot(osun_wp_nonfunctional.ppl)
```

### Converting KDE output into grid object

```{r}
gridded_osun_wp_functional_ppl <- as.SpatialGridDataFrame.im(osun_wp_functional.ppl)

gridded_osun_wp_nonfunctional_ppl <- as.SpatialGridDataFrame.im(osun_wp_nonfunctional.ppl)
```

### Converting gridded output into raster

After that we need to convert the gridded kernel density objects into RasterLayer

```{r}
osun_wp_functional_ppl_raster <- raster(gridded_osun_wp_functional_ppl)
osun_wp_nonfunctional_ppl_raster <- raster(gridded_osun_wp_nonfunctional_ppl)
```

Checking the properties of both raster layers:

```{r}
osun_wp_functional_ppl_raster
osun_wp_nonfunctional_ppl_raster
```

The crs property is NA for both, so we need to assign projection systems

```{r}
projection(osun_wp_functional_ppl_raster) <- CRS("init=EPSG:26392")
projection(osun_wp_nonfunctional_ppl_raster) <- CRS("init=EPSG:26392")
```

## Displaying Kernel Density Maps on OpenStreetMap

